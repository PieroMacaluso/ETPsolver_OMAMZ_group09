\documentclass[11pt, a4paper, leqno]{article}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{parskip}
\usepackage{libertine} % font bello
\usepackage[paper=a4paper,top=1in,bottom=1.1in,right=1in,left=1in]{geometry} % margini

\usepackage{enumitem} % liste pi√π compatte (se ce ne saranno)
%\setlist[enumerate]{itemsep=0.0em}
\setlist[itemize]{itemsep=0.0em}
\usepackage[compact]{titlesec}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[]{algorithm2e}

\newcommand{\nome}[2]{
\begin{minipage}[t]{0.185\linewidth}
	\centering #1\par
	\centering\small (#2)\par
\end{minipage}
}

% Questo era utile per evidenziare le cose "dubbie e da correggere"
% Poi si elimina il comando cosi' non restano \boh{} in giro
%\usepackage{xcolor}
%\newcommand{\boh}[1]{\textcolor{red}{#1}}

\newcommand{\eqp}[1]{\textit{(eq. \ref{#1})}}
\newcommand{\eq}[1]{\textit{\ref{#1}}}

\begin{document}	
	\begin{center}
		{\huge\textbf{OMA Final Report}}\par
		\vspace{0.3em}
		{\large\textbf{Group 9}}\par
		\vspace{1em}
		\nome{Piero Macaluso}{s252894}
		\nome{Lorenzo Manicone}{s217189}
		\nome{Donato Tortoriello}{s205639}
		\nome{Ludovico Pavesi}{s246422}
		\nome{Alberto Romano}{s254036} % 164371
	\end{center}

	\section{Building conflict matrix}
	
	Was done by taking each couple of exams and counting students enrolled in both. This was agonizingly slow, taking about 20 seconds on istance 6.
	
	Also, it was a mistake since before that it worked differently but the entire data structure has been changed multiple times.
	
	It was later improved by iterating over students once and, for each student, taking every couple of exams they're enrolled in and incrementing the right cell in the conflict matrix.
	
	Finding this performance problem (which appeared by mistake, mind you) required us to use a profiler, but nobody cares about stuff that's really useful in the real world and we'll almost surely use in future (these absurd algorithms... most of us will never see them again).

	\section{Initial solution generation}
	
	\subsection{Random}
	
	Initially we tried generating random starting solutions: that is, to each exam assign a random time slot. This was very fast, but even after thousands of runs we couldn't find even a single feasible solution on ``real'' instances. It worked on the ``test'' instance, however.
	
	\subsection{Greedy 1 (``Extremely Stupid Greedy'')}
	
	We tried to implement a very simplistic greedy algorithm:
	
	\begin{algorithm}[H]
		%\KwData{dati}
		%\KwResult{risultato}
		%initialization\;
		\ForEach{exam}{
			\ForEach{timeslot}{
				\If{exam can be scheduled in timeslot}{
					assign exam to timeslot\;
					break (evaluate next exam)\;
				}
			}
		}
		\caption{The very simplistic greedy algorithm}
	\end{algorithm}

	This never yielded a feasible solution, as when it got near the end of the exam list there were no more non-conflicting time slots available.
	
	It should be noted that this algorithm is deterministic, as it always produced the same solution.
	
	\subsection{Greedy 2 (``Slightly More Cultured Greedy'')}
	
	An attempt was made to introduce nondeterminism in the previously mentioned greedy algorithm. This was achieved by randomizing the order in which time slots are examined: again, this never yielded a single feasible solution, even after hundreds of runs.
	
	\subsection{FFS Algorithm}
	
	\dots
	
	\section{Further solutions generation}
	
	\subsection{Genetic algorithm}
	
	We tried running a genetic algorithm implementation anyway, with ``Random'' and ``Greedy 2'' initial solutions especially. It worked fine in the test instance, reaching the optimum solution in around 5-10 iterations with single-point crossover and a mutation (assigning a random time slot to an exam) probability of $0.1$, on real instances it never produced a feasible solution, not even after thousands of iterations.
	
	\subsection{Simulated mutant genetic annealing of doom\texttrademark}
	
	\dots
	
\end{document}
