\documentclass[11pt, a4paper, leqno]{article}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{parskip}
\usepackage{libertine} % font bello
\usepackage[paper=a4paper,top=1in,bottom=1.1in,right=1in,left=1in]{geometry} % margini

\usepackage{enumitem} % liste piÃ¹ compatte (se ce ne saranno)
%\setlist[enumerate]{itemsep=0.0em}
\setlist[itemize]{itemsep=0.0em}
\usepackage[compact]{titlesec}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[]{algorithm2e}

\newcommand{\nome}[2]{
\begin{minipage}[t]{0.185\linewidth}
	\centering #1\par
	\centering\small (#2)\par
\end{minipage}
}

% Questo era utile per evidenziare le cose "dubbie e da correggere"
% Poi si elimina il comando cosi' non restano \boh{} in giro
%\usepackage{xcolor}
%\newcommand{\boh}[1]{\textcolor{red}{#1}}

\newcommand{\eqp}[1]{\textit{(eq. \ref{#1})}}
\newcommand{\eq}[1]{\textit{\ref{#1}}}

\begin{document}	
	\begin{center}
		{\huge\textbf{OMA Final Report}}\par
		\vspace{0.3em}
		{\large\textbf{Group 9}}\par
		\vspace{1em}
		\nome{Piero Macaluso}{s252894}
		\nome{Lorenzo Manicone}{s217189}
		\nome{Donato Tortoriello}{s205639}
		\nome{Ludovico Pavesi}{s246422}
		\nome{Alberto Romano}{s254036} % 164371
	\end{center}

	\section{Building conflict matrix}
	
	Was done by taking each couple of exams and counting students enrolled in both. This was agonizingly slow, taking about 20 seconds on istance 6.
	
	Also, it was a mistake since before that it worked differently but the entire data structure has been changed multiple times.
	
	It was later improved by iterating over students once and, for each student, taking every couple of exams they're enrolled in and incrementing the right cell in the conflict matrix.
	
	Finding this performance problem (which appeared by mistake, mind you) required us to use a profiler, but nobody cares about stuff that's really useful in the real world and we'll almost surely use in future (these absurd algorithms... most of us will never see them again).

	\section{Initial solution generation}
	
	\subsection{Random}
	
	Initially we tried generating random starting solutions: that is, to each exam assign a random time slot. This was very fast, but even after thousands of runs we couldn't find even a single feasible solution on ``real'' instances. It worked on the ``test'' instance, however.
	
	\subsection{Greedy 1 (``Extremely Stupid Greedy'')}
	
	We tried to implement a very simplistic greedy algorithm that iterates over each exam, finds the first available time slot by iterating over all time slots and checking conflicts, and placing it there. The aim was mainly to see what a feasible solution ``looked like''.
	
	%\begin{algorithm}[H]
	%	%\KwData{dati}
	%	%\KwResult{risultato}
	%	%initialization\;
	%	\
	%	\ForEach{exam}{
	%		\While{}{
	%			\If{exam can be scheduled in timeslot}{
	%				assign exam to timeslot\;
	%				break (evaluate next exam)\;
	%			}
	%		}
	%	}
	%	\caption{The very simplistic greedy algorithm}
	%\end{algorithm}

	This never yielded a feasible solution for any of the real instances, as when it got near the end of the exam list there were no more non-conflicting time slots available.
	
	It should be noted that this algorithm is deterministic, as it always produced the same solution.
	
	\subsection{Greedy 2 (``Slightly More Cultured Greedy'')}
	
	An attempt was made to introduce nondeterminism in the previously mentioned greedy algorithm. This was achieved by randomizing the order in which time slots are examined: again, this never yielded a single feasible solution, even after hundreds of runs.
	
	\subsection{Greedy 3 (``Timeslots and Conflicts'')}
	
	We tried sorting exams by some more meaningful criteria than their ID, and then assigning a random available time slot to each exam in that order.
	
	Initially we sorted them by number of conflicting exams. This solution was simple but found feasible solutions only for \textit{instance01}, so we decided to sort them first by the number of unavailable timeslots (timeslots with conflicting exams already scheduled), then by the number of conflicts. Since the order depends on current solution (each time an exam is scheduled, the ``number of unavailable timeslots'' for some other exams change), the list needed to be sorted again at each step.
	
	\begin{algorithm}[H]
%		%\KwData{dati}
%		%\KwResult{risultato}
%		%initialization\;
		$list \gets \text{all exams to be scheduled, sorted by }\textit{(number of unavailable slot, number of conflicts)}$\;
		\While{$list\text{ is not empty}$}{
			$E \gets \textit{ first element from }list$\;
			$T \gets \textit{ random available timeslot}$\;
			schedule $E$ in $T$\;
			remove $E$ from $list$\;
			sort $list$ again\;
		}	
		\caption{Algorithm with Timeslots and Conflicts sorting}
	\end{algorithm}

	But even so, there were still no feasible solutions for the other instances.
	
	\subsection{Greedy 4 (``First Feasible Solution Creation'')}
	
	With the previous algorithm, the tipping point was the absence of available timeslost for the current exam when getting near the ond of the list.
	
	So we decided to unschedule all the conflicting exams of the current one when that situation was encountered, sort and retry scheduling them again.
	
	In order to avoid unstable or ``oscillating'' situations, we fixed a maximum number of ``retires'': if this limit is exceeded, the algorithm restarts from an empty solution (or from a different partial neighbor, see \ref{neighbors}). This was a great step forward, as it worked with all instances. There was only one problem: in more complex instance it takes more time to get a feasible solution.
	
	\begin{algorithm}[H]
		%\KwData{dati}
		%\KwResult{risultato}
		%initialization\;
		$backup \gets \text{current solution (even an empty one)}$\;
		$sol \gets \text{current solution (even an empty one)}$\;
		$I \gets 0$\;
		$list \gets \text{all exams to be scheduled, sorted by }\textit{(number of unavailable slot, number of conflicts)}$\;
		\While{$list$ is not empty}{
			\If{\textit{I} >= limit}{
				$sol \gets backup$\;
				restart the alogithm\;
			}
			$E \gets \textit{ first element from }list$\;
			$T \gets \textit{ random available timeslot}$\;
			\eIf{$T$ is valid (not null)}{
				schedule $E$ in $T$\;
				remove $E$ from $list$\;
			}{
				\ForEach{conflicting exam $C$ of $E$}{
					unschedule $C$\;
				}
				$I \gets I + 1$\;
			}
			sort $list$ again\;
		}	
		\caption{First Feasible Solution algorithm}
	\end{algorithm}
	
	 This was a great step forward, working with all instances. There was only one problem: in larger instances, like \textit{instance06}, it took a lot of time to generate an initial solution.
	
	\subsection{Greedy 5 (``Cached First Feasible Solution Creation'')}
	
	
	
	\section{Further solutions generation}
	
	\subsection{Genetic algorithm}
	
	We tried running a genetic algorithm implementation anyway, with ``Random'' and ``Greedy 2'' initial solutions especially. It worked fine in the test instance, reaching the optimum solution in around 5-10 iterations with single-point crossover and a mutation (assigning a random time slot to an exam) probability of $0.1$, on real instances it never produced a feasible solution, not even after thousands of iterations.
	
	\subsection{Mutant Simulated Annealing\texttrademark}
	
	\dots
	
\end{document}
